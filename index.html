<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>原型</title>
</head>
<body>


<script>
    //变量
    /*1.基本数据类型：undefined，null，boolean，number，string
      2.引用类型：引用类型的值是保存在内存中的对象(只能为引用类型添加属性)
      3.检测类型：-typeof操作符检测一个变量是字符串，数值，布尔值还是undefined(基本数据类型)的最佳工具。null会返回object
                  var s=null      typeof s
                  -instanceof检测引用类型

    */

    var val='huran';
    console.log(typeof val);

    //    设计模式的存在原因是为了代码的复用性和可维护性。应遵守以下原则
    /* 1.  开闭原则（对扩展开放，对修改关闭）
     2.  里氏转换原则（子类继承父类，可单独运行）
     3.  依赖倒转原则（引用一个对象，如果这个对象有底层类型，直接引用底层）
     4.  接口隔离原则（每个接口都是一种角色）
     5.  合成/聚合复用原则（新对象应使用一些已有对象，使之成为新对象的一部分）*/


    //    一.工厂模式的作用
    /*1.  需要依赖具体的环境创建不同实例
     2.  创建大量具有相同属性的小对象      (解决了创建多个相似对象的问题，没有解决对象识别问题)*/

    /*function createPerson() {
     var o=new Object();
     o.name="张三";
     o.year="30";
     o.sex="men";
     o.returnName=function(){
     alert(this.name);
     };
     return o;
     }

     var person1=createPerson("李四","20","men");
     var person2=createPerson("李丽","22","women");
     alert(person1.name);*/



    //   二、构造函数模式
    //   缺点：每个方法都要在每个实例上重新创建一遍

    /* function Person(name,age,sex) {                          //构造函数始终以大写字母开头
     this.name=name;
     this.age=age;
     this.sex=sex;
     this.returnName=returnName;
     }
     function  returnName(){
     alert(this.name);
     }

     var person1=new Person("李四","20","men");                //创建Person实例  将构造函数中的作用域赋给新对象
     //任何函数通过new操作符来调用，就可以作为构造函数
     var person2=new Person("李丽","22","women");              //person1和person2分别保存着Person不同的实例,这两个对象都有construct属性，指向Person
     alert(person1.name);*/



    //三、原型(prototype)模式
    //原型对象
    /*1.创建的每个函数都有prototype(原型)属性，这个属性指向函数的原型对象。
     原型对象会自动获得一个construct属性，这个属性包含一个指向原型属性所在函数的指针。
     2. 构造函数、原型与实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，
     每个实例又包含一个指向原型对象的内部指针
     2. Person.prototype指向了原型对象   prototype.construct又指回Person
     3. 当调用构造函数创建一个新的实例后，该实例内部包含一个指向构造函数的原型对象的指针(prototype)
     实例中的指针仅指向原型，而非构造函数
     4. __proto__存在与实例与构造函数之间，对脚本不可见
     5. isPrototypeOf  只要原型链中出现过的原型，都可以说是该原型链派生的实例的原型
     Person.prototype.isPrototypeOf(person1)     //true  person1中包含指向 Person.prototype的指针
     6. ECMAScript中增加Object.getPrototypeOf方法，该方法返回prototype的值
     Object.getPrototypeOf(person1.name)         //胡冉
     7. 代码读取每个对象的属性时，会执行一次搜索，目标是有给定名字的属性。
     首先搜索对象实例本身，没有的话继续搜索指针指向的原型对象。
     8. 可以通过对象实例访问保存在原型中的值，但不能重写。如果在实例中添加一个存在的属性，
     这个属性会屏蔽原型对象中保存的同名的属性，但不会修改那个属性。
     使用delete操作符可完全删除实例属性，从而可以重新访问原型中的属性
     person1.name="张三";
     alert(person1.name)   //张三     搜索实例属性时就搜索到这个属性值
     alert(person2.name)   //胡冉     实例中没有这个属性，继续搜索原型中name属性
     delete person1.name              删除实例中name属性，恢复对原型中name属性的连接
     alert(person1.name)   //胡冉

     9. hasOwnPrototype  检查一个属性是存在实例中还是原型中。存在实例中返回true
     person1.hasOwnProperty("name")
     10.原型与in操作符    无论该属性存在原型还是实例中都返回true
     "name" in person1
     11.ECMAScript中：Object.keys()取得对象上所有可枚举的实例属性
     Object.keys(Person.prototype)    //name age school sayName
     12.得到所有实例属性，不管是否可枚举  Object.getOwnPropertyNames()
     Object.getOwnPropertyNames(Person.prototype)
     13.在已经创建实例的情况下，把原型修改为另一个对象会切断构造函数与最初原型，
     现有原型与之前存在的实例对象的关系, 此时Person的prototype指向new Person prototype新的原型对象
     实例中的prototype指向最初的Person.prototype
     14.缺点是：省略了为构造函数传递初始化参数这一环节，所有实例在默认情况下都将取得相同的属性值
     最大问题：原型中所有属性被很多实例所共享
     */
    /*    function Person() {


     }
     Person.prototype.name = '胡冉';             //prototype是通过调用构造函数而创建的那个对象实例的原型对象
     Person.prototype.age = '22';
     Person.prototype.school = 'WTU';
     Person.prototype.sayName = function () {     //将sayName()方法添加到Person原型属性中
     alert(this.name);
     };*/

    //1.更简单的原型语法
    /* var huRan=new Person();
     Person.prototype={              //本质上完全重写了默认的prototype对象，因此construct指向构造函数Object
     name:"胡冉",                //在已经创建实例的情况下，把原型修改为另一个对象会切断构造函数与最初原型，现有原型与之前存在的实例对象的关系
     age:"22",                   //此时Person的prototype指向new Person prototype新的原型对象
     school:"WTU",
     sayName:function(){
     alert(this.name);
     }

     };
     alert(huRan.sayName());       //先创建了一个Person实例，又重写了原型，此时huRan中的prototype指向最初的Person.prototype
     */

    //四、组合使用构造函数模式和原型模式
    /* 1.构造函数模式用于定义实例属性，原型模式用于定义方法共享的属性。
     这样每个实例都有自己的一份实例属性副本，但又共享着对方法的引用，最大限度节省内存。
     这种方式支持向构造函数传入参数。
     */
    /* function Person(name, age, sex) {
     this.name = name;
     this.age = age;
     this.sex = sex;
     this.friend = ['ben', 'lucy'];
     }
     Person.prototype = {
     constructor: Person,
     sayName: function () {
     alert(this.name);
     }

     };
     var person1 = new Person('huRan', '22', 'girl');           //实例属性都是在构造函数中定义的
     var person2 = new Person('jack', '25', 'boy');             //所有实例共享的sayName是在原型中定义的
     console.log(person1.name);
     person1.sayName();
     person1.friend.push('jacky');
     console.log(person1.friend);
     console.log(person2.friend);*/


    //五、动态原型模式
    /* 1.把所有信息都封装在构造函数内，通过在构造函数内初始化原型（检查某个应该存在的方法是否有效，来决定是否初始化），
     保持了使用构造函数和原型模式的优点。
     */
    /*  function Person(name, age, sex) {
     this.name = name;
     this.age = age;
     this.sex = sex;
     this.friend = ['ben', 'lucy'];

     //这段代码只会在初次调用构造函数时才会执行
     if(typeof this.sayName!="function"){
     Person.prototype.sayName=function(){
     alert(this.name);
     };
     }
     }
     var person=new Person("huRan","22","girl");
     person.sayName();*/


    //六.寄生构造函数模式
    /*1. Person中创建一个新对象，并以相同的属性值和方法初始化该对象，再返回这个对象
     2. 除使用new操作符之外，与工厂模式相同
     3. 其他模式可用情况下不使用此模式
     */

    /* function Person() {
     var o=new Object();
     o.name="张三";
     o.year="30";
     o.sex="men";
     o.returnName=function(){
     alert(this.name);
     };
     return o;                                   //返回的对象与构造函数和构造函数原型之间没有任何关系
     }

     var person1=Person("李四","20","men");
     var person2=Person("李丽","22","women");
     alert(person1.name);*/


    //七、稳妥构造函数模式
    /* 1.稳妥对象：指的是没有公共属性，其方法也不引用this对象和new操作符调用构造函数，适合一些安全环境。
     */

    /*function Person(name,age,sex){
     //创建要返回的对象
     var o =new Object();
     o.sayName=function(){
     alert(o.name);
     };
     //返回对象
     return o;
     }
     var person=new Person('huRan','22','girl');
     person.sayName();
     */


    //检查属性是存在原型还是对象中
    //返回true表示属性存在在原型中
    /* function checkProperty(obj,name){
     return !obj.hasOwnProperty(name) && (name in obj);
     }

     var person1 = new Person();
     var person2 = new Person();
     person1.name="小吴";
     alert(Object.keys(Person.prototype));             //name age school sayName   person中所有可枚举的属性
     alert(Object.getOwnPropertyNames(Person.prototype)); //construct name age school sayName  所有属性
     alert(Object.keys(person1));                      //name  person1中所有可枚举的属性
     alert(person1.hasOwnProperty("name"));            //true  检查name属性是存在实例还是原型中
     alert("name" in person1);                         //true  存在原型还是实例中都返回true
     alert(checkProperty(person1,"name"));             //false 存在原型中则返回true
     delete person1.name;                              //删除实例中的name属性

     alert(person1.name);                              //原型对象的好处是让所有对象实例共享它所包含的属性和方法
     alert(person1.age);                               //(不必在构造函数中定义对象实例的信息,而是将信息添加到原型对象中)
     alert(person1.school);
     alert(person1.sayName==person2.sayName);          //ture  person1和person2访问的是同一组属性和sayName函数
     alert(Object.getPrototypeOf(person1).name);       //Object.getPrototypeOf()取得一个对象的原型
     alert(Person.prototype.isPrototypeOf(person1));   //确定返回的对象实际是这个对象的原型
     alert(person2.hasOwnProperty("name"));            //false 存在原型中*/




    //一.继承
    /* 1.两种继承方式:接口继承(只继承方法签名)和实现继承(继承实际的方法)，
     函数由于没有签名，ECMAScript中使用实现继承，主要依靠原型链。
     2.原型链基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法
     3.所有函数的默认原型的Object的实例，默认原型包含指向Object.prototype的指针
     4.确定原型与实例的关系：
     -instanceof（实例与原型链中出现过的构造函数返回true）
     type instanceof Object/SuperType/UpperType
     可以说type是三个函数中任意一个的实例

     -isPrototypeOf (只要是原型链中出现过的原型，可以说是该原型链所派生的实例的原型)
     Object/SuperType/UpperType.prototype.isPrototypeOf(type)
     5.重写或添加超类型中不存在的方法，要将方法写在替换原型的语句之后
     6.缺点：使用原型链继承中不能使用字面量创建原型方法,会导致重写原型链
     7.缺点：原型链在创建子类型实例时，不能向超类型的构造函数中传递参数
     8.一般很少单独使用原型链
     9.UpperType的新原型等于SuperType实例，新原型拥有superType实例的所有属性和方法,
     内部还有一个指针指向superType的prototype
     10.type指向UpperType原型，UpperType原型又指向SuperType的原型，
     type中的constructor现在指向SuperType，因为UpperType.prototype的constructor被重写(UpperType的原型指向了SuperType的原型)
     */
    /*function SuperType() {
     this.property=true;
     }
     SuperType.prototype.getSuperValue=function(){
     return this.property;
     };

     function UpperType(){
     this.newproperty=false;
     }
     UpperType.prototype=new SuperType();            //通过创建SuperType实例，并将实例赋值给UpperType的原型实现继承
     UpperType.prototype.getUpperValue=function(){   //实质是重写原型对象，原本在SuperType实例中的属性和方法也被UpperType.prototype继承
     return this.newproperty;
     };

     SuperType.prototype.getSuperValue=function(){   //重写或添加超类型中不存在的方法，要将方法写在替换原型的语句之后
     return false;
     };

     var type=new UpperType();
     console.log(type.getUpperValue());       //经历三步，搜索原型、UpperType.prototype、SuperType.prototype
     console.log(type instanceof SuperType);  //测试原型与实例关系，实例与原型链中出现过的构造函数返回true
     console.log(Object.prototype.isPrototypeOf(type));  //只要是原型链中出现过的原型，可以说是该原型链所派生的实例的原型
     */

    //二.借用构造函数(经典继承)
    /*1.基本思想：在子类型构造函数的内部调用超类型构造函数。
     2.缺点：方法都定义在构造函数中，函数无法复用，因此很少单独使用
     */
    /*
     function SuperType(){
     this.color=['red','blue','green'];
     }

     function UpperType(){
     SuperType.call(this)        //call(this,参数，参数)和apply(this,[参数,参数])是为了改变this的指向(改变执行上下文顺序)
     }

     var type=new UpperType();       //在type对象上执行SuperType中定义的所有对象初始化方法
     type.color.push('black');       //UpperType的每个实例就有一个自己的color副本
     console.log(type.color);
     */



    //三、组合继承(伪经典继承)
    /* 1.指将原型链与借用构造函数的技术组合到一起，
     思路：使用原型链来实现对原型属性和方法的继承，通过构造函数来实现对实例属性的继承。
     2.优点：通过原型上定义方法实现了函数复用，又能保证每个实例都有自己的属性
     3.为最常用的继承模式
     4.缺点：无论什么情况都会调用两次超类型构造函数，一次是创建子类型原型时，另一次是在子类型构造函数内部
     */
    /*
     function SuperType(name){
     this.name=name;                                     //SuperType构造函数定义了name，color两个属性
     this.color=['red','green','blue'];
     }
     SuperType.prototype.sayName=function(){                 //SuperType的原型定义了sayName方法
     alert(this.name);
     };

     function UpperType(name,age){
     SuperType.call(this,name);                          //UpperType构造函数在调用SuperType时传入了name参数  第二次调用
     this.age=age;                                       //又定义了自己的属性age
     }

     UpperType.prototype=new SuperType();                    //将SuperType的实例赋值给UpperType的原型   第一次调用
     UpperType.prototype.sayAge=function(){                  //在新原型上定义了方法sayAge
     alert(this.age);
     };

     var type1=new UpperType('huRan',18);                    //让两个不同的UpperType实例拥有了自己属性，又可以使用相同的方法
     type1.color.push('black');
     console.log(type1.color);
     type1.sayName();
     type1.sayAge();

     var type2=new UpperType('linda',22);
     console.log(type2.color);
     type2.sayAge();*/


    //四、原型式继承
    /*1.借助原型基于已有的对象创建新对象，ECMAScript中新增Object.create()方法规范化原型式继承
     Object.create(新对象，额外属性会覆盖已有的属性)
     2.使用场景：在没有必要创建构造函数，只是想让一个对象与另一个对象保持一致时
     3.缺点：引用类型值的属性始终都会共享相同的值，与原型模式一样
     */
    /*    var person={
     name:'lucy',
     friends:['bob','ben','jack']
     };

     var person1=Object.create(person);
     person1.name='huRan';
     person1.friends.push('rose');
     console.log(person1.name);
     console.log(person1.friends);

     var person2=Object.create(person);
     person2.name='Alice';
     console.log(person2.name);
     console.log(person2.friends);

     var person3=Object.create(person,{
     name:{
     value:'roy'
     }
     });
     console.log(person3.name);*/



    //五、寄生式继承
    //思路与寄生式构造函数、工厂模式类似，即创建一个仅用于封装继承过程的函数
    //主要考虑对象而不是自定义类型和构造函数的情况下适用。同样函数不能复用
    /*    function createPerson(ori){         //createPerson接收一个参数
     //通过调用函数创建一个新对象
     var clone=Object(ori);          //把这个对象ori传递给Object函数，再将结果赋值给clone
     //以某种方式来增强对象
     clone.sayHi=function(){         //为clone对象添加一个方法
     alert('hi');
     };
     return clone;                   //返回clone这个对象
     }
     var person={
     name:'huRan',
     fried:['linda','lucy']
     };
     var another=createPerson(person);
     another.sayHi();*/

    //六、寄生组合式继承
    /*1.通过借用构造函数来继承属性，通过原型链来继承方法。
     本质上就是使用寄生式继承来继承超类型的原型，然后将结果指定给子类型的原型
     2.是引用类型最佳的继承范式

     */

    /*
     function inheritProto(UpperType,SuperType) {
     var obj=Object(SuperType.prototype);        //创建超类型原型副本
     obj.constructor=UpperType;                  //为创建的副本添加constructor，弥补因重写原型而失去默认的constructor
     UpperType.prototype=obj;                    //将超类型原型副本赋值给子类型的原型
     }

     function SuperType(name){
     this.name=name;
     }
     SuperType.prototype.sayName=function(){
     alert(this.name);
     };

     function UpperType(name,age) {
     SuperType.call(this,name);                 //只调用了一次SuperType构造函数，避免了在UpperType的原型上创建不必要的属性，还能保持原型链不变
     this.age=age;
     }
     inheritProto(UpperType,SuperType);
     UpperType.prototype.sayAge=function(){
     alert(this.age);
     };

     var person=new UpperType('sam',22);
     person.sayName();
     */






    //函数表达式
    /*定义函数的两种方式：函数声明和函数表达式
     函数声明   function demo(obj1,obj2){}   函数声明有个重要特征：函数声明提升  执行代码前先执行函数声明
     函数表达式 var demo=function(obj1,obj2){}    在使用前必须前赋值
     */


    //一、递归函数
    //递归函数：一个函数通过名字调用自身
    //用arguments.callee(一个指向正在指向函数的指针)代替函数名
    /* function compareNum(num){
     if(num<=1){
     return 1;
     }else{
     return num *compareNum(num-1);
     }
     }*/

   /* var compare = compareNum;         //将函数保存在变量中
    compareNum = null;                //将变量设置为null
    console.log(compare(4));        //但在调用compare时必须执行compareNum（），但此时compareNum已经不是函数，会抛出错误

    //解决办法，用arguments.callee(一个指向正在指向函数的指针)代替函数名
    function compareNum(num) {
        if (num <= 1) {
            return 1;
        } else {
            return num * arguments.callee(num - 1);
        }
    }


    //但是在严格模式下不能通过脚本访问arguments.callee，可以用命名函数表达式来替代
    var compareNumber = (function compareNumber(num) {
        if (num <= 1) {
            return 1;
        } else {
            return num * compareNumber(num - 1);
        }
    });*/


    //闭包
    /*1.闭包是指：有权访问另一个函数作用域中的变量的函数
      2.创建方式：在一个函数内部创建另一个函数
      3.作用域链：本质上是一个指向变量对象的指针列表，它只引用但不包含实际变量对象
      4.函数第一次被调用时，会创建一个执行环境及相应的作用域链，并把作用域链赋值给一个特殊的的内部对象scope。
        然后使用this，argument和其他命名参数的值来初始化这个函数的活动对象。
        在作用域链中，外部函数的活动对象始终处于第二位
      5.一般来说函数执行完毕后，局部活动对象会被销毁，内存中仅保存全局变量，但在闭包中不同。
        在另一个函数内部定义的函数会将包含函数(外部函数)的活动对象添加到它的作用域链中。
      6.谨慎使用：闭包会携带包含它的函数的作用域，因此更占内存，过度使用会导致占用内存过多
      7.总结：在一个函数内部定义了另一个函数，就创建了闭包。闭包有权访问函数内部的所有变量。
        -后台执行环境中，闭包包含着自己的作用域，包含函数的作用域和全局作用域。
        -通常函数的作用域及其所有变量在执行结束后被销毁
        -但当函数返回了一个闭包，这个函数的作用域就会一直保存在闭包中知道闭包不存在
*/
/*
    function compare(object1, object2) {            //定义了compare函数
        if (object1 > object2) {                    //第一次调用会创建this，argument，object1，object2的活动对象
            return -1;
        } else if (object2 > object1) {
            return 1
        } else {
            return 0;
        }
    }
    var result=compare(5,10);                       //在全局作用域中调用compare
    console.log(result);                            /!*全局执行环境的变量对象this，compare，result在compare()
                                                      执行环境的作用域链处于第二位*!/*/


    /*function demo(name) {
        return function (object1, object2) {        //此匿名在外部函数中被返回后,它的作用域链初始化为包含外部函数的活动对象和全局变量对象。即可访问外部函数中的所有变量。函数的作用域链中会包含外部函数demo()的活动对象
            var value1 = object1[name];             //访问了外部函数的变量name
            var value2 = object2[name];
            if (value1 > value2) {
                return -1;
            } else if (value2 > value1) {
                return 1
            } else {
                return 0;
            }
        };
    }

    //创建函数
    var test=demo('name');                         /!*demo函数在执行完毕后，其执行环境的作用域链会被销毁，但活动对象不会被销毁，
                                                     因为匿名函数的作用域链仍在引用这个活动对象，所以依然保存在内存中，知道匿名函数被销毁*!/
    //调用函数
    var result=test({name:'rita'},{name:'lucy'});
    console.log(result);

    //接触对匿名函数的引用(以便释放内存)
    test=null;                                      //等于通知垃圾回收例程将其清楚。随着匿名函数的作用域链被销毁，其他作用域(除全局作用域)也都可以安全销毁
*/


    //一、闭包与变量
    //1.闭包指取得包含函数中任何变量的最后一个值


   /* function createFn() {
        var result=new Array();
        for(var i=0;i<10;i++){
            result[i]=function(){
                return i;
            }
        }
        return result;                      //看似返回一个自己索引值的数组，实际返回的都是10
    }*/

    //通过创建另一个匿名函数强制让闭包符合预期
/*    function createFn() {
        var result=new Array();
        for(var i=0;i<10;i++){
            result[i]=function(num){        //将匿名函数的结果马上赋值给数组result
                return function(){
                    return num;             //此匿名函数内部又创建了一个访问num的闭包，这样result数组中每个函数都有num变量的一个副本
                };
            }(i)
        }
        return result;                      //看似返回一个自己索引值的数组，实际返回的都是10
    }*/


    //二、this对象
    /*1.this对象是在运行时基于函数的执行环境绑定的。
        全局函数中，this=window
        函数被当做某个对象的方法调用时,this等于那个对象
      2.匿名函数的执行环境具有局限性，一般this通常指向window(在call和apply改变函数执行环境的情况下，this指向其对象)
        */
   /* var name="the window";               //创建全局变量name
    var object={
        name:"my object",
        getName:function(){
            return function(){
                return this.name;
            };
        }
    };
    console.log(object.getName()());      //返回the window
*/

    //把外部作用域中的this对象保存在闭包能够访问到的变量里，闭包就可以访问my object
    var name="the window";
    var object={
        name:"my object",
        getName:function(){
            var _this=this;
            return function(){
                return _this.name;
            };
        }
    };
    console.log(object.getName()());      //返回the window


    //三、内存泄露
    //1.ie9之前在闭包的作用域链中保存html元素，意味着该元素无法被销毁
 /*   function demo(){
        var ele=document.getElementById("demo");
        ele.onclick=function(){
            console.log(ele.id);           //匿名函数保存了一个对demo的活动对象的引用(ele),只要匿名函数在，ele的引用次数最少是1，所占内存无法销毁
        };
    }*/

    //解决办法
    function demo(){
        var ele=document.getElementById("demo");
        var id=ele.id;                 //把ele.id的副本保存在一个变量中，并在闭包中引用该变量
        ele.onclick=function(){
            console.log(id);           //匿名函数保存了一个对demo的活动对象的引用(ele),只要匿名函数在，所占内存无法销毁
        };
        ele=null;                      //解除对dom对象的引用，确保正常回收被占用的内存
    }


    //四、模仿块级作用域
    // 1. js没有块级作用域的概念,意味着在块级语句中定义的变量，实际上是在包含函数中而非语句中创建的
    // 2. 形式：将函数声明包含在括号里，表示它实际上是函数表达式 。没有圆括号包含会出错，因为js把关键字function当成函数声明的开始，而函数声明后不能再跟括号
    /*3.  使用范围：经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多变量和参数
          过多的全局变量和函数会导致命名冲突*/


    /*    function count(num){
            for(var i=0;i<num;i++){
               alert(i)
            }
            alert(i);         //变量i是定义在count的活动对象中的，从被定义开始，在函数内部就可以访问
        }*/

    //匿名函数可以模仿块级作用域(私有作用域)
    //只要临时需要一些变量，就可以使用私有作用域
/*
    (function(){         //将函数声明包含在括号里，表示它实际上是函数表达式 。没有圆括号包含会出错，因为js把关键字function当成函数声明的开始，而函数声明后不能再跟括号

    })();                //这个括号表示会立即调用这个函数

    function count(num){
        (function(){                              //匿名函数中任何变量，在执行完毕后被销毁
            for(var i=0;i<num;i++){               //在for循环中插入了一个私有作用域 ,i只能在循环中使用
                alert(i)
            }
        })();
        alert(i);

    }
*/


    //五、私有变量
    //1.私有变量包含函数的参数，局部变量和在函数内部定义的的其他函数
    //2.特权方法：有权访问私有变量和私有函数的共有方法(在一个函数内部创建闭包，闭包通过自己的作用域链也可以访问变量)
    //3.缺点:构造函数模式针对每个实例都会创建同样的一组新方法，静态私有变量可以解决这个问题


    //1.在构造函数中定义特权方法
/*
    function myFn(){
        //定义私有变量
        var privateVar=10;
        //定义私有函数
        function privateFn(){
            return false;
        }

        //特权方法
        this.publicFn=function(){
            privateVar++;
            return privateFn;
        };
    }
*/

   /* function Person(name){
        this.getName=function(){          //这两个方法是在构造函数内部定义的，它们作为闭包可以通过作用域链访问name
            return name;                  //私有变量name在Person中每个实例都不同，因为每次调用构造函数都会重新创建这两个方法
        };
        this.setName=function(val){
            name=val;
        };
    }

    var person=new Person('huRan');
    console.log(person.getName());
    person.setName('rita');
    console.log(person.getName());*/


    //静态私有变量
    //2.通过私有作用域定义私有变量或函数，也可以创建特权方法








</script>



</body>
</html>